# ~/akoben-clean/src/agents/vision/vision_analyzer.pyimport cv2import osimport numpy as npimport mathfrom scipy.signal import find_peaksimport base64import jsonimport google.generativeai as genaiimport akoben_config # <<<=== IMPORTATION DU FICHIER CONFIG# --- Définitions précédentes (inchangées) ---AKOBEN_CLEAN_DIR = "/home/lasko/akoben-clean"AKOBEN_RUNTIME_DIR = "/home/lasko/akoben"# ... (Toutes les fonctions: analyze_rsi..., extract_rsi..., find_rsi...,#      analyze_price..., extract_zigzag..., find_zigzag_corners_shi_tomasi...#      sont supposées être définies ici comme dans les versions précédentes) ...def analyze_rsi_zone_fixed_percent(relative_image_path_in_runtime: str, start_percent: float = 0.59, end_percent: float = 0.71):    image_path = os.path.join(AKOBEN_RUNTIME_DIR, "tradingview_captures", relative_image_path_in_runtime)    img_color = cv2.imread(image_path, cv2.IMREAD_COLOR)    if img_color is None: return None, None    height, width, _ = img_color.shape    rsi_y_top = int(height * start_percent); rsi_y_bottom = int(height * end_percent)    if rsi_y_top >= rsi_y_bottom: rsi_y_bottom = rsi_y_top + 1    rsi_y_top = max(0, rsi_y_top); rsi_y_bottom = min(height, rsi_y_bottom)    rsi_roi = img_color[rsi_y_top:rsi_y_bottom, :]    # Pas besoin de sauvegarder le ROI à chaque fois ici, on peut le commenter    # output_rsi_roi_path = os.path.join(AKOBEN_CLEAN_DIR, "output_rsi_roi_fixed.png")    # try: cv2.imwrite(output_rsi_roi_path, rsi_roi)    # except Exception as e: print(f"  - ERREUR sauvegarde ROI RSI (Fixe) : {e}")    return rsi_roi, (rsi_y_top, rsi_y_bottom)def extract_rsi_curve_by_color(rsi_roi_image: np.ndarray):    if rsi_roi_image is None: return None    hsv_roi = cv2.cvtColor(rsi_roi_image, cv2.COLOR_BGR2HSV)    lower_purple = np.array([125, 100, 149]); upper_purple = np.array([135, 200, 254])    mask = cv2.inRange(hsv_roi, lower_purple, upper_purple)    mask_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, np.ones((3,3), np.uint8), iterations=1)    # Pas besoin de sauvegarder le masque à chaque fois    # output_mask_path = os.path.join(AKOBEN_CLEAN_DIR, "output_rsi_mask.png")    # try: cv2.imwrite(output_mask_path, mask_closed)    # except Exception as e: print(f"  - ERREUR sauvegarde Masque RSI : {e}")    return mask_closeddef find_rsi_extrema(rsi_mask: np.ndarray, prominence_threshold: float = 3.0, distance_threshold: int = 15):    if rsi_mask is None or rsi_mask.ndim != 2: return [], []    h, w = rsi_mask.shape; rsi_curve_y = []; rsi_curve_x = []    for x in range(w):        y_coords = np.where(rsi_mask[:, x] == 255)[0]        if len(y_coords) > 0: y_avg = int(np.mean(y_coords)); rsi_curve_y.append(y_avg); rsi_curve_x.append(x)    if not rsi_curve_y: return [],[]    signal_y = np.array(rsi_curve_y)    peaks_indices, _ = find_peaks(-signal_y, prominence=prominence_threshold, distance=distance_threshold)    peaks_coords = [(rsi_curve_x[i], rsi_curve_y[i]) for i in peaks_indices]    troughs_indices, _ = find_peaks(signal_y, prominence=prominence_threshold, distance=distance_threshold)    troughs_coords = [(rsi_curve_x[i], rsi_curve_y[i]) for i in troughs_indices]    return peaks_coords, troughs_coordsdef analyze_price_zone_fixed_percent(relative_image_path_in_runtime: str, start_percent: float = 0.06, end_percent: float = 0.59):    image_path = os.path.join(AKOBEN_RUNTIME_DIR, "tradingview_captures", relative_image_path_in_runtime)    img_color = cv2.imread(image_path, cv2.IMREAD_COLOR)    if img_color is None: return None, None    height, width, _ = img_color.shape    price_y_top = int(height * start_percent); price_y_bottom = int(height * end_percent)    if price_y_top >= price_y_bottom: price_y_bottom = price_y_top + 1    price_y_top = max(0, price_y_top); price_y_bottom = min(height, price_y_bottom)    price_roi = img_color[price_y_top:price_y_bottom, :]    # Pas besoin de sauvegarder    # output_price_roi_path = os.path.join(AKOBEN_CLEAN_DIR, "output_price_roi_fixed.png")    # try: cv2.imwrite(output_price_roi_path, price_roi)    # except Exception as e: print(f"  - ERREUR sauvegarde ROI PRIX (Fixe) : {e}")    return price_roi, (price_y_top, price_y_bottom)def extract_zigzag_by_color(price_roi_image: np.ndarray):    if price_roi_image is None: return None    hsv_roi = cv2.cvtColor(price_roi_image, cv2.COLOR_BGR2HSV)    lower_blue = np.array([100, 150, 100]); upper_blue = np.array([120, 255, 255])    mask = cv2.inRange(hsv_roi, lower_blue, upper_blue)    mask_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, np.ones((3,3), np.uint8), iterations=1)    # Pas besoin de sauvegarder    # output_mask_path = os.path.join(AKOBEN_CLEAN_DIR, "output_zigzag_mask.png")    # try: cv2.imwrite(output_mask_path, mask_closed)    # except Exception as e: print(f"  - ERREUR sauvegarde Masque ZigZag : {e}")    return mask_closeddef find_zigzag_corners_shi_tomasi(price_roi_image: np.ndarray, zigzag_mask: np.ndarray,                                    max_corners: int = 50, quality_level: float = 0.01, min_distance: int = 10):    if price_roi_image is None or price_roi_image.ndim != 3: return []    if zigzag_mask is not None and (zigzag_mask.ndim != 2 or zigzag_mask.shape[:2] != price_roi_image.shape[:2]): return []    gray_roi = cv2.cvtColor(price_roi_image, cv2.COLOR_BGR2GRAY)    corners = cv2.goodFeaturesToTrack(image=gray_roi, maxCorners=max_corners, qualityLevel=quality_level,                                       minDistance=min_distance, mask=zigzag_mask)    if corners is None: return []    corner_coords = [tuple(map(int, c.ravel())) for c in corners]    corner_coords.sort(key=lambda pt: pt[0])    return corner_coords# --- Fonction d'affinage LLM (inchangée, utilise api_key en argument) ---def refine_zigzag_vertices_with_llm(price_roi_image: np.ndarray,                                     candidate_vertices: list[tuple[int, int]], # Correction type hint                                     api_key: str):    if price_roi_image is None: return None    if not candidate_vertices: return []    if not api_key: return candidate_vertices # Retourne candidats si pas de clé    print("Tentative d'affinage des sommets ZigZag avec LLM multimodal...")    try:        genai.configure(api_key=api_key)        model = genai.GenerativeModel('gemini-pro-vision')    except Exception as e: print(f"  - ERREUR config API: {e}"); return candidate_vertices    try:        retval, buffer = cv2.imencode('.jpg', price_roi_image)        if not retval: raise ValueError("Échec encodage JPEG")        image_bytes = buffer.tobytes()        image_parts = [{"mime_type": "image/jpeg", "data": image_bytes}]    except Exception as e: print(f"  - ERREUR préparation image: {e}"); return candidate_vertices    candidate_list_str = ", ".join([f"({x},{y})" for x, y in candidate_vertices])    prompt = f"""Analyze the provided image, which shows a financial chart's price area. Focus on the prominent blue 'ZigZag' line. Identify the significant turning points (peaks/highs and troughs/lows) *exclusively on this blue ZigZag line*.An initial algorithm detected: {candidate_list_str}Critically evaluate these points: Keep only correct significant turning points on the blue ZigZag line. Discard incorrect points (on straight segments, other lines, edges). Add obvious missed significant turning points.Output ONLY the final, validated list of coordinates as a valid JSON list of lists: [[x1, y1], [x2, y2], ...]. No other text or markdown."""    try:        print("  - Appel API Gemini...")        response = model.generate_content([prompt, image_parts[0]], stream=False)        response_text = response.text        print("  - Réponse reçue.")    except Exception as e: print(f"  - ERREUR appel API: {e}"); return candidate_vertices # Retourne candidats si API échoue    try:        if "```json" in response_text: response_text = response_text.split("```json")[1].split("```")[0].strip()        elif "```" in response_text: response_text = response_text.split("```")[1].split("```")[0].strip()        else: response_text = response_text.strip()        refined_list_of_lists = json.loads(response_text)        refined_vertices = []        if isinstance(refined_list_of_lists, list):            for item in refined_list_of_lists:                if isinstance(item, list) and len(item) == 2 and all(isinstance(coord, int) for coord in item):                    refined_vertices.append(tuple(item))                else: raise ValueError(f"Format JSON interne invalide: {item}")        else: raise ValueError("Réponse JSON n'est pas une liste.")        refined_vertices.sort(key=lambda pt: pt[0])        print(f"  - Réponse parsée. Sommets affinés : {len(refined_vertices)}")        return refined_vertices    except Exception as e: print(f"  - ERREUR parsing/validation réponse LLM: {e}\n  - Réponse brute: '{response_text}'"); return candidate_vertices # Retourne candidats si parsing échoue# --- Point d'entrée (Utilise akoben_config.py) ---if __name__ == "__main__":    print("--- Test d'analyse d'image (Affinage LLM via akoben_config.py) ---")    # Lire la clé depuis le fichier de configuration    try:        GOOGLE_API_KEY = akoben_config.GOOGLE_API_KEY        if not GOOGLE_API_KEY or GOOGLE_API_KEY == 'VOTRE_CLE_API_ICI_A_COLLER':             print("!!! ERREUR: Clé API non définie ou valeur par défaut dans akoben_config.py.")             GOOGLE_API_KEY = None    except AttributeError:         print("!!! ERREUR: Variable GOOGLE_API_KEY non trouvée dans akoben_config.py.")         GOOGLE_API_KEY = None    except ModuleNotFoundError:         print("!!! ERREUR: Fichier akoben_config.py non trouvé.")         GOOGLE_API_KEY = None    if not GOOGLE_API_KEY:        print("!!! Affinage LLM désactivé. Veuillez créer akoben_config.py et y mettre votre clé API.")        # Pas d'exit() ici, on continue avec les points initiaux    # Utiliser l'image que vous avez préparée (qui s'appelle temporairement original.png)    test_image_relative_path = '2025-03-26/setup_20250326083927/original.png'    # 1. Isoler le ROI du PRIX    price_image_roi, price_y_coords = analyze_price_zone_fixed_percent(        test_image_relative_path, start_percent=0.06, end_percent=0.59    )    if price_image_roi is not None:        print(f"ROI PRIX (Fixe) extrait avec succès pour {test_image_relative_path}.")        # 2. Extraire le masque ZigZag        zigzag_mask = extract_zigzag_by_color(price_image_roi)        if zigzag_mask is not None:            print("Masque ZigZag extrait avec succès.")            # 3. Trouver les coins initiaux avec Shi-Tomasi (Paramètres qui donnaient ~14 points)            initial_zigzag_corners = find_zigzag_corners_shi_tomasi(                price_roi_image=price_image_roi,                zigzag_mask=zigzag_mask,                max_corners=30,                quality_level=0.1, # Les paramètres qui donnaient ~14 points                min_distance=25            )            if initial_zigzag_corners:                print(f"Coins initiaux (Shi-Tomasi) trouvés : {len(initial_zigzag_corners)}")                # 4. Affiner avec LLM (si API Key est disponible)                if GOOGLE_API_KEY:                    refined_zigzag_vertices = refine_zigzag_vertices_with_llm(                        price_image_roi,                        initial_zigzag_corners,                        GOOGLE_API_KEY                    )                    if refined_zigzag_vertices is None: # Si l'API a échoué mais qu'on avait des points initiaux                         print("INFO: Échec de l'affinage LLM, utilisation des points initiaux.")                         refined_zigzag_vertices = initial_zigzag_corners                else:                    print("INFO: Clé API manquante, affinage LLM sauté. Utilisation des points initiaux.")                    refined_zigzag_vertices = initial_zigzag_corners                # On a maintenant refined_zigzag_vertices (soit du LLM, soit les initiaux)                print(f"Sommets ZigZag à visualiser (affinés ou initiaux) : {len(refined_zigzag_vertices)}")                # 5. Visualiser les sommets sur le ROI du PRIX                price_roi_with_vertices = price_image_roi.copy()                for x, y in refined_zigzag_vertices:                    cv2.circle(price_roi_with_vertices, (x, y), radius=6, color=(255, 0, 255), thickness=2) # Magenta                output_vertices_path = os.path.join(AKOBEN_CLEAN_DIR, "output_zigzag_vertices_llm_refined.png")                try:                    cv2.imwrite(output_vertices_path, price_roi_with_vertices)                    print(f"  - Image ROI PRIX avec sommets affinés/initiaux (magenta) sauvegardée : {output_vertices_path}")                except Exception as e:                    print(f"  - ERREUR lors de la sauvegarde de l'image avec sommets : {e}")            else:                print("Aucun coin initial (Shi-Tomasi) n'a été trouvé.")        else:            print("Échec de l'extraction du masque ZigZag.")    else:        print(f"Échec de l'extraction du ROI PRIX pour {test_image_relative_path}.")    # --- Code pour RSI (toujours désactivé) ---    # ...    print("--- Fin du test ---")