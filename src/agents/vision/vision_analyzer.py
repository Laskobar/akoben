# ~/akoben-clean/src/agents/vision/vision_analyzer.pyimport cv2import osimport numpy as npimport mathfrom scipy.signal import find_peaks# Définir les chemins de baseAKOBEN_CLEAN_DIR = "/home/lasko/akoben-clean"AKOBEN_RUNTIME_DIR = "/home/lasko/akoben"# --- analyze_rsi_zone_fixed_percent (INCHANGÉ) ---def analyze_rsi_zone_fixed_percent(relative_image_path_in_runtime: str,                                   start_percent: float = 0.59,                                   end_percent: float = 0.71):    # ... (code identique) ...    image_path = os.path.join(AKOBEN_RUNTIME_DIR, "tradingview_captures", relative_image_path_in_runtime)    # ... (reste du code identique) ...    img_color = cv2.imread(image_path, cv2.IMREAD_COLOR)    if img_color is None: return None, None    height, width, _ = img_color.shape    # ... (reste du code identique) ...    rsi_y_top = int(height * start_percent)    rsi_y_bottom = int(height * end_percent)    # ... (reste du code identique) ...    rsi_roi = img_color[rsi_y_top:rsi_y_bottom, :]    # ... (reste du code identique) ...    return rsi_roi, (rsi_y_top, rsi_y_bottom)# --- extract_rsi_curve_by_color (INCHANGÉ) ---def extract_rsi_curve_by_color(rsi_roi_image: np.ndarray):    # ... (code identique) ...    if rsi_roi_image is None: return None    # ... (reste du code identique) ...    hsv_roi = cv2.cvtColor(rsi_roi_image, cv2.COLOR_BGR2HSV)    # Plage HSV basée sur #7e57c2    # ... (calcul plage identique) ...    lower_purple = np.array([125, 100, 149])    upper_purple = np.array([135, 200, 254]) # Utilisation de la plage validée    # ... (reste du code identique) ...    mask = cv2.inRange(hsv_roi, lower_purple, upper_purple)    # ... (nettoyage masque identique) ...    mask_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, np.ones((3,3), np.uint8), iterations=1)    # ... (sauvegarde identique) ...    return mask_closed# --- find_rsi_extrema (INCHANGÉ) ---def find_rsi_extrema(rsi_mask: np.ndarray, prominence_threshold: float = 3.0, distance_threshold: int = 15):    # ... (code identique) ...    if rsi_mask is None or rsi_mask.ndim != 2: return [], []    # ... (extraction courbe identique) ...    signal_y = np.array(rsi_curve_y) # rsi_curve_y doit être calculée avant    rsi_curve_x = list(range(len(signal_y))) # Assumons x simple si non extrait avant    # ... (find_peaks identique) ...    # Assurez-vous que rsi_curve_x et rsi_curve_y sont correctement peuplées dans la version complète de la fonction    # Calcul de rsi_curve_y et rsi_curve_x (extrait de la fonction originale pour clarté)    h, w = rsi_mask.shape    rsi_curve_y = []    rsi_curve_x = []    for x in range(w):        y_coords = np.where(rsi_mask[:, x] == 255)[0]        if len(y_coords) > 0:            y_avg = int(np.mean(y_coords))            rsi_curve_y.append(y_avg)            rsi_curve_x.append(x)    if not rsi_curve_y: return [],[]    signal_y = np.array(rsi_curve_y)    # Recherche pics/creux    peaks_indices, _ = find_peaks(-signal_y, prominence=prominence_threshold, distance=distance_threshold)    peaks_coords = [(rsi_curve_x[i], rsi_curve_y[i]) for i in peaks_indices]    troughs_indices, _ = find_peaks(signal_y, prominence=prominence_threshold, distance=distance_threshold)    troughs_coords = [(rsi_curve_x[i], rsi_curve_y[i]) for i in troughs_indices]    # ... (reste du code identique) ...    return peaks_coords, troughs_coords# --- NOUVELLE FONCTION : analyze_price_zone_fixed_percent ---def analyze_price_zone_fixed_percent(relative_image_path_in_runtime: str,                                     start_percent: float = 0.06, # Commence après le haut (~6%)                                     end_percent: float = 0.59): # Finit juste avant le RSI (~59%)    """    Isole la zone du graphique principal (prix, bougies, zigzag) en utilisant    des pourcentages fixes de la hauteur totale de l'image.    """    image_path = os.path.join(AKOBEN_RUNTIME_DIR, "tradingview_captures", relative_image_path_in_runtime)    print(f"Analyse (Pourcentage Fixe) de la zone PRIX pour : {image_path}")    if not os.path.exists(image_path):        print(f"ERREUR : Le fichier image n'existe pas : {image_path}")        return None, None    img_color = cv2.imread(image_path, cv2.IMREAD_COLOR)    if img_color is None:        print(f"ERREUR : Impossible de charger l'image : {image_path}")        return None, None    height, width, _ = img_color.shape    print(f"Image couleur chargée ({height}x{width}).")    if not (0.0 <= start_percent < end_percent <= 1.0):        print(f"ERREUR: Pourcentages invalides (start={start_percent}, end={end_percent}).")        return None, None    price_y_top = int(height * start_percent)    price_y_bottom = int(height * end_percent)    if price_y_top >= price_y_bottom: price_y_bottom = price_y_top + 1    price_y_top = max(0, price_y_top)    price_y_bottom = min(height, price_y_bottom)    print(f"  - Zone PRIX (Pourcentage Fixe) estimée : Y de {price_y_top} à {price_y_bottom}")    price_roi = img_color[price_y_top:price_y_bottom, :]    output_price_roi_path = os.path.join(AKOBEN_CLEAN_DIR, "output_price_roi_fixed.png")    try:        cv2.imwrite(output_price_roi_path, price_roi)        print(f"  - Image ROI du PRIX (Fixe) sauvegardée : {output_price_roi_path}")        return price_roi, (price_y_top, price_y_bottom)    except Exception as e:        print(f"  - ERREUR lors de la sauvegarde du ROI PRIX (Fixe) : {e}")        return None, None# --- NOUVELLE FONCTION : extract_zigzag_by_color ---def extract_zigzag_by_color(price_roi_image: np.ndarray):    """    Extrait la ligne ZigZag d'un ROI de prix en utilisant un seuillage de couleur HSV.    """    if price_roi_image is None:        print("ERREUR: ROI Prix invalide fourni pour l'extraction de couleur.")        return None    print("Tentative d'extraction de la ligne ZigZag par couleur...")    hsv_roi = cv2.cvtColor(price_roi_image, cv2.COLOR_BGR2HSV)    # Définir la plage de couleur pour le BLEU VIF du ZigZag en HSV    # Le bleu vif a une Teinte autour de 100-120. Saturation et Valeur élevées.    # À ajuster après test !    # lower_blue = np.array([95, 100, 100])    # upper_blue = np.array([125, 255, 255])    # === PLAGE BLEU V2 (plus resserrée, basée sur l'image exemple) ===    lower_blue = np.array([100, 150, 100]) # Saturation et Valeur Min plus hautes    upper_blue = np.array([120, 255, 255])    print(f"  - Utilisation de la plage HSV pour ZigZag: Bas={lower_blue}, Haut={upper_blue}")    mask = cv2.inRange(hsv_roi, lower_blue, upper_blue)    # Nettoyage morphologique - Peut-être juste une fermeture pour connecter segments    kernel_size = 3    kernel = np.ones((kernel_size, kernel_size), np.uint8)    mask_closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1) # Fermeture seule    print(f"  - Masque créé et nettoyé (Fermeture seule kernel={kernel_size}).")    output_mask_path = os.path.join(AKOBEN_CLEAN_DIR, "output_zigzag_mask.png")    try:        cv2.imwrite(output_mask_path, mask_closed)        print(f"  - Masque ZigZag sauvegardé : {output_mask_path}")        return mask_closed    except Exception as e:        print(f"  - ERREUR lors de la sauvegarde du masque ZigZag : {e}")        return None# --- Point d'entrée (Modifié pour tester l'extraction ZigZag) ---if __name__ == "__main__":    print("--- Test d'analyse d'image (Extraction Masque ZigZag) ---")    test_image_relative_path = '2025-03-26/setup_20250326083927/original.png'    if test_image_relative_path == 'VOTRE_IMAGE_ICI.png':         print("\n!!! ATTENTION : Veuillez modifier la variable 'test_image_relative_path' !!!\n")    else:        # 1. Isoler le ROI du PRIX        price_image_roi, price_y_coords = analyze_price_zone_fixed_percent(            test_image_relative_path,            start_percent=0.06, # ~6%            end_percent=0.59   # ~59%        )        # 2. Si le ROI est valide, extraire le masque ZigZag        if price_image_roi is not None:            print(f"ROI PRIX (Fixe) extrait avec succès.")            zigzag_mask = extract_zigzag_by_color(price_image_roi)            if zigzag_mask is not None:                print("Extraction du masque ZigZag par couleur réussie. Vérifiez output_zigzag_mask.png.")                # Prochaine étape : trouver les coins/vertices dans zigzag_mask            else:                print("Échec de l'extraction du masque ZigZag par couleur.")        else:            print("Échec de l'extraction du ROI PRIX (Fixe).")    # --- Code pour RSI (temporairement désactivé pour se concentrer sur ZigZag) ---    # print("\n--- Test RSI (désactivé pour le moment) ---")    # rsi_image_roi, rsi_y_coords = analyze_rsi_zone_fixed_percent(...)    # if rsi_image_roi is not None:    #     rsi_mask = extract_rsi_curve_by_color(rsi_image_roi)    #     if rsi_mask is not None:    #         peaks, troughs = find_rsi_extrema(rsi_mask, ...)    #         # ... visualisation ...    # --- Fin Code RSI désactivé ---    print("--- Fin du test ---")